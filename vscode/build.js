#!/usr/bin/env node

/**
 * VS Code Extension Build Script
 * 
 * Builds the VS Code extension including:
 * - Extension host code (vscode/src/extension.ts)
 * - Webview bundle (vscode/src/webview/main.ts + shared src/)
 */

import { build } from 'esbuild';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'node:child_process';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.resolve(__dirname, '..');

/**
 * Get version from root package.json
 * @returns {string} Current version
 */
function getVersion() {
  const packagePath = path.join(projectRoot, 'package.json');
  const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
  return packageJson.version;
}

/**
 * Check for missing translation keys
 */
async function checkMissingKeys() {
  console.log('üì¶ Checking translations...');
  try {
    await import('../scripts/check-missing-keys.js');
  } catch (error) {
    console.error('‚ö†Ô∏è  Warning: Failed to check translation keys:', error.message);
  }
}

/**
 * Copy directory recursively
 */
function copyDirectory(sourceDir, targetDir) {
  if (!fs.existsSync(sourceDir)) {
    return;
  }

  if (!fs.existsSync(targetDir)) {
    fs.mkdirSync(targetDir, { recursive: true });
  }

  const entries = fs.readdirSync(sourceDir, { withFileTypes: true });
  for (const entry of entries) {
    const sourcePath = path.join(sourceDir, entry.name);
    const targetPath = path.join(targetDir, entry.name);

    if (entry.isDirectory()) {
      copyDirectory(sourcePath, targetPath);
    } else {
      fs.copyFileSync(sourcePath, targetPath);
    }
  }
}

/**
 * Build extension host (Node.js environment)
 */
async function buildExtensionHost() {
  console.log('üì¶ Building extension host...');

  await build({
    entryPoints: ['vscode/src/host/extension.ts'],
    bundle: true,
    outfile: 'dist/vscode/extension.js',
    format: 'cjs', // VS Code extensions use CommonJS
    platform: 'node',
    target: ['node18'],
    external: ['vscode'], // vscode module is provided by VS Code
    sourcemap: true,
    minify: true,
    define: {
      'process.env.NODE_ENV': '"production"'
    }
  });

  console.log('‚úÖ Extension host built');
}

/**
 * Build webview bundle (browser environment)
 */
async function buildWebview() {
  console.log('üì¶ Building webview bundle...');

  // Build JS bundle
  await build({
    entryPoints: ['vscode/src/webview/main.ts'],
    bundle: true,
    outfile: 'dist/vscode/webview/bundle.js',
    format: 'iife',
    platform: 'browser',
    target: ['chrome120'],
    sourcemap: true,
    minify: true,
    define: {
      'process.env.NODE_ENV': '"production"',
      'global': 'globalThis'
    },
    inject: ['./scripts/buffer-shim.js'],
    loader: {
      '.css': 'empty', // Don't bundle CSS in JS
      '.woff2': 'empty',
      '.woff': 'empty',
      '.ttf': 'empty',
      '.eot': 'empty'
    },
    assetNames: '[name]'
  });

  // Build iframe-render-worker bundle (heavy renderers: mermaid, vega, etc.)
  console.log('üì¶ Building iframe-render-worker...');
  await build({
    entryPoints: {
      'iframe-render-worker': 'mobile/src/webview/iframe-render-worker.ts'
    },
    bundle: true,
    outdir: 'dist/vscode/webview',
    format: 'iife',
    platform: 'browser',
    target: ['chrome120'],
    minify: true,
    define: {
      'process.env.NODE_ENV': '"production"',
      'global': 'globalThis',
      'PLATFORM': '"vscode"'
    },
    inject: ['./scripts/buffer-shim.js'],
    loader: {
      '.css': 'css',
      '.woff': 'dataurl',
      '.woff2': 'dataurl',
      '.ttf': 'dataurl'
    },
    // Mermaid is loaded separately to keep bundle size manageable
    external: ['mermaid']
  });

  // Build CSS bundle separately
  await build({
    entryPoints: ['src/ui/styles.css'],
    bundle: true,
    outfile: 'dist/vscode/webview/styles.css',
    loader: {
      '.css': 'css',
      '.woff2': 'file',
      '.woff': 'empty',
      '.ttf': 'empty',
      '.eot': 'empty'
    },
    assetNames: '[name]',
    minify: true
  });

  console.log('‚úÖ Webview bundle built');
}

/**
 * Copy static assets
 */
function copyAssets() {
  console.log('ÔøΩ Copying assets...');

  const outdir = 'dist/vscode';

  // Create package.json for VS Code extension
  const packageJson = JSON.parse(fs.readFileSync(path.join(projectRoot, 'package.json'), 'utf8'));
  
  // Extract VS Code specific fields
  const vscodePackage = {
    name: packageJson.name,
    displayName: packageJson.displayName,
    description: packageJson.description,
    version: packageJson.version,
    publisher: packageJson.publisher,
    license: packageJson.license,
    engines: {
      vscode: packageJson.engines?.vscode || '^1.85.0'
    },
    categories: packageJson.categories,
    activationEvents: packageJson.activationEvents,
    main: './extension.js',
    contributes: packageJson.contributes,
    icon: packageJson.icon,
    repository: packageJson.repository,
    keywords: packageJson.keywords?.filter(k => !k.includes('chrome'))
  };

  fs.writeFileSync(
    path.join(outdir, 'package.json'),
    JSON.stringify(vscodePackage, null, 2)
  );
  console.log('  ‚Ä¢ package.json');

  // Copy package.nls*.json files for VSCode menu localization
  const nlsSourceDir = path.join(projectRoot, 'vscode', '_locales');
  if (fs.existsSync(nlsSourceDir)) {
    const nlsFiles = fs.readdirSync(nlsSourceDir).filter(f => f.startsWith('package.nls') && f.endsWith('.json'));
    for (const nlsFile of nlsFiles) {
      fs.copyFileSync(path.join(nlsSourceDir, nlsFile), path.join(outdir, nlsFile));
    }
    console.log(`  ‚Ä¢ package.nls*.json (${nlsFiles.length} files)`);
  }

  // Copy locales
  copyDirectory('src/_locales', path.join(outdir, 'webview', '_locales'));
  console.log('  ‚Ä¢ _locales');

  // Copy themes
  copyDirectory('src/themes', path.join(outdir, 'webview', 'themes'));
  console.log('  ‚Ä¢ themes');

  // Create iframe-render.html with inlined JS (for diagram rendering)
  // Mermaid is inlined first, then the worker script
  const mermaidJs = fs.readFileSync(path.join(projectRoot, 'node_modules/mermaid/dist/mermaid.min.js'), 'utf8');
  const iframeWorkerJs = fs.readFileSync(path.join(outdir, 'webview', 'iframe-render-worker.js'), 'utf8');
  const iframeHtml = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="script-src 'unsafe-inline' 'unsafe-eval'; style-src 'unsafe-inline';">
  <title>Render Frame</title>
  <style>
    * { margin: 0; padding: 0; }
    html, body { background: transparent; width: 1400px; min-height: 600px; }
  </style>
</head>
<body>
  <div id="render-container"></div>
  <canvas id="png-canvas"></canvas>
  <script>${mermaidJs}</script>
  <script>${iframeWorkerJs}</script>
</body>
</html>`;
  fs.writeFileSync(path.join(outdir, 'webview', 'iframe-render.html'), iframeHtml);
  // Remove standalone worker JS file since it's now inlined
  fs.unlinkSync(path.join(outdir, 'webview', 'iframe-render-worker.js'));
  console.log('  ‚Ä¢ iframe-render.html');

  // Copy icons
  copyDirectory('icons', path.join(outdir, 'icons'));
  console.log('  ‚Ä¢ icons');

  // Copy settings panel styles
  if (fs.existsSync('vscode/src/webview/settings-panel.css')) {
    fs.copyFileSync('vscode/src/webview/settings-panel.css', path.join(outdir, 'webview', 'settings-panel.css'));
    console.log('  ‚Ä¢ settings-panel.css');
  }

  // Copy fonts if they exist
  if (fs.existsSync('src/fonts')) {
    copyDirectory('src/fonts', path.join(outdir, 'webview', 'fonts'));
    console.log('  ‚Ä¢ fonts');
  }

  // Copy README from vscode directory
  if (fs.existsSync('vscode/README.md')) {
    fs.copyFileSync('vscode/README.md', path.join(outdir, 'README.md'));
    console.log('  ‚Ä¢ README.md');
  }

  // Copy LICENSE
  if (fs.existsSync('LICENSE')) {
    fs.copyFileSync('LICENSE', path.join(outdir, 'LICENSE'));
    console.log('  ‚Ä¢ LICENSE');
  }

  // Create .vscodeignore
  const vscodeignore = `
.vscode/**
node_modules/**
src/**
**/*.ts
**/*.map
.gitignore
tsconfig.json
`;
  fs.writeFileSync(path.join(outdir, '.vscodeignore'), vscodeignore.trim());
  console.log('  ‚Ä¢ .vscodeignore');

  console.log('‚úÖ Assets copied');
}

/**
 * Main build function
 */
async function main() {
  const version = getVersion();
  console.log(`üî® Building VS Code Extension... v${version}\n`);

  // Check translations
  await checkMissingKeys();

  // Change to project root for esbuild to work correctly
  process.chdir(projectRoot);

  try {
    // Clean output directory
    const outdir = 'dist/vscode';
    if (fs.existsSync(outdir)) {
      fs.rmSync(outdir, { recursive: true, force: true });
    }
    fs.mkdirSync(outdir, { recursive: true });
    fs.mkdirSync(path.join(outdir, 'webview'), { recursive: true });

    // Build all parts
    await buildExtensionHost();
    await buildWebview();
    copyAssets();

    console.log(`\n‚úÖ Build complete! Output: ${outdir}/`);

    // Package the extension
    console.log('\nüì¶ Packaging extension...');
    const vsceCmd = path.join(projectRoot, 'node_modules', '.bin', 'vsce');
    execSync(`"${vsceCmd}" package`, { cwd: outdir, stdio: 'inherit' });
    console.log('‚úÖ Extension packaged!');

  } catch (error) {
    console.error('\n‚ùå Build failed:', error);
    process.exit(1);
  }
}

main();
